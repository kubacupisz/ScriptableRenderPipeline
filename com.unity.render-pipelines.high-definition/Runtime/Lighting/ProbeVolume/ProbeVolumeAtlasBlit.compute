#pragma kernel ProbeVolumeAtlasBlitKernel PROBE_VOLUME_ATLAS_BLIT_KERNEL=ProbeVolumeAtlasBlitKernel

#ifdef SHADER_API_PSSL
#   pragma argument( scheduler=minpressure ) // instruct the shader compiler to prefer minimizing vgpr usage
#endif

#pragma only_renderers d3d11 ps4 xboxone vulkan metal switch

// #include "Packages/com.unity.render-pipelines.core/ShaderLibrary/Common.hlsl"

StructuredBuffer<float3> _ProbeVolumeAtlasReadBuffer;
RWTexture2D<float4> _ProbeVolumeAtlasWriteTexture;

uint _ProbeVolumeAtlasReadBufferCount;
float3 _ProbeVolumeResolution;
float3 _ProbeVolumeResolutionInverse;
float4 _ProbeVolumeAtlasScaleBias;
float4 _ProbeVolumeAtlasResolutionAndInverse;

uint2 ComputeWriteIndexFromReadIndex(uint readIndex, float3 resolution, float3 resolutionInverse, float4 scaleBias, float4 atlasResolutionAndInverse)
{
    // return uint2(readIndex % 1024u, readIndex >> 10);

    // _ProbeVolumeAtlasReadBuffer[z * resolutionY * resolutionX + y * resolutionX + x]
    // TODO: Could implement as floating point operations, which is likely faster.
    // Would need to verify precision.
    uint x = readIndex % (uint)resolution.x;
    uint y = (readIndex / (uint)resolution.x) % (uint)resolution.y;
    uint z = readIndex / ((uint)resolution.y * (uint)resolution.x);

    // Atlas layout:
    // int width = resolution.x * resolution.z;
    // int height = resolution.y;
    // scaleBias: x,y is width and height (scale) z,w offset into atlas (bias)
    uint atlasX = x + z * (uint)resolution.x;
    uint atlasY = y;

    float atlasU = (float)atlasX + scaleBias.z * atlasResolutionAndInverse.x;
    float atlasV = (float)atlasY + scaleBias.w * atlasResolutionAndInverse.y;

    return uint2((uint)atlasU, (uint)atlasV);
}

// Warning this needs to match with kBatchSize in ProbeVolumeSystem.cs
#define BATCH_SIZE 256
[numthreads(BATCH_SIZE, 1, 1)]
void PROBE_VOLUME_ATLAS_BLIT_KERNEL(uint groupThreadId : SV_GroupThreadID, uint groupId : SV_GroupID, uint3 dispatchThreadId : SV_DispatchThreadID)
{
    uint readIndex = groupId * BATCH_SIZE + groupThreadId;
    if (readIndex >= _ProbeVolumeAtlasReadBufferCount) { return; }

    uint2 writeIndex = ComputeWriteIndexFromReadIndex(
        readIndex,
        _ProbeVolumeResolution,
        _ProbeVolumeResolutionInverse,
        _ProbeVolumeAtlasScaleBias,
        _ProbeVolumeAtlasResolutionAndInverse
    );

    float4 res;
    res.rgb = _ProbeVolumeAtlasReadBuffer[readIndex];
    res.a = 1.0f;
    _ProbeVolumeAtlasWriteTexture[writeIndex] = res;
}
